{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap c6d091a9229c08eade29","webpack:///./src/randomKey.js","webpack:///./src/guessFileExtension.js","webpack:///./src/worker.js","webpack:///./src/wrappers/gdalOpen.js","webpack:///./src/wrappers/gdalClose.js","webpack:///./src/wrappers/gdalGetRasterCount.js","webpack:///./src/wrappers/gdalGetRasterXSize.js","webpack:///./src/wrappers/gdalGetRasterYSize.js","webpack:///./src/wrappers/gdalGetProjectionRef.js","webpack:///./src/wrappers/gdalGetGeoTransform.js","webpack:///./src/wrappers/gdalTranslate.js","webpack:///./src/wrappers/gdalWarp.js"],"names":["randomKey","length","chars","result","i","Math","floor","random","guessFileExtension","args","supportedFormats","PNG","JPEG","GTiff","includes","formatStr","indexOf","Object","keys","DATASETPATH","initialized","registry","errorHandling","CPLErr","CENone","CEDebug","CEWarning","CEFailure","CEFatal","CPLErrorReset","CPLGetLastErrorMsg","CPLGetLastErrorNo","CPLGetLastErrorType","self","Module","text","console","log","ccall","cwrap","cplQuietFnPtr","Runtime","addFunction","GDALOpen","GDALClose","GDALGetRasterCount","GDALGetRasterXSize","GDALGetRasterYSize","GDALGetProjectionRef","GDALGetGeoTransform","GDALTranslate","GDALWarp","LoamFlushFS","datasetFolders","FS","lookupPath","node","contents","values","forEach","unmount","getPath","rmdir","mkdir","postMessage","ready","importScripts","onmessage","msg","success","message","data","func","arguments","id","error","rootPath","file","filename","directory","File","name","mount","WORKERFS","files","Blob","blobs","filePath","datasetPtr","errorType","Error","datasetPath","returnFileBytes","readFile","encoding","byteOffset","_malloc","Float64Array","BYTES_PER_ELEMENT","geoTransform","HEAPF64","subarray","_free","Array","from","dataset","argPtrsArray","Uint32Array","map","lengthBytesUTF8","argStr","concat","stringToUTF8","argPtrsArrayPtr","HEAPU32","set","translateOptionsPtr","optionsErrType","ptr","MEMFS","usageErrPtr","Int32Array","setValue","newDatasetPtr","cleanUp","warpAppOptionsPtr","datasetListPtr"],"mappings":"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","file":"loam-worker.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"loam\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"loam\"] = factory();\n\telse\n\t\troot[\"loam\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c6d091a9229c08eade29","// https://stackoverflow.com/questions/10726909/random-alpha-numeric-string-in-javascript\nexport default function randomKey(length = 32, chars = '0123456789abcdefghijklmnopqrstuvwxyz') {\n    let result = '';\n\n    for (let i = length; i > 0; i--) {\n        result += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return result;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/randomKey.js","export default function guessFileExtension(args) {\n    const supportedFormats = {\n        PNG: 'png',\n        JPEG: 'jpg',\n        GTiff: 'tif'\n    };\n\n    // Match GDAL 2.1 behavior: if output format is unspecified, the output format is GeoTiff\n    // This changes to auto-detection based on extension in GDAL 2.3, so if/when we upgrade to that,\n    // this will need to be changed.\n    if (!args.includes('-of')) {\n        return 'tif';\n    }\n    // Otherwise, try to guess the format from the arguments; this isn't meant for validation, just\n    // to provide a reasonable filename if it ever ends up getting exposed to the user.\n    let formatStr = args[args.indexOf('-of') + 1];\n\n    if (Object.keys(supportedFormats).includes(formatStr)) {\n        return supportedFormats[formatStr];\n    }\n    // If the next parameter after `-of` isn't in our supported formats, then the user is trying\n    // to specify a format that's not supported by gdal-js, or their gdal_translate arguments\n    // array is malformed. Either way, it's not really this function's business to validate\n    // that, so just return the best guess as to what the user might have intended. Any errors\n    // will be handled by the main function's error handling code.\n    return formatStr;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/guessFileExtension.js","/* global FS, Runtime, importScripts, postMessage */\n\n// w is for wrap\n// The wrappers are factories that return functions which perform the necessary setup and\n// teardown for interacting with GDAL inside Emscripten world.\nimport wGDALOpen from './wrappers/gdalOpen.js';\nimport wGDALClose from './wrappers/gdalClose.js';\nimport wGDALGetRasterCount from './wrappers/gdalGetRasterCount.js';\nimport wGDALGetRasterXSize from './wrappers/gdalGetRasterXSize.js';\nimport wGDALGetRasterYSize from './wrappers/gdalGetRasterYSize.js';\nimport wGDALGetProjectionRef from './wrappers/gdalGetProjectionRef.js';\nimport wGDALGetGeoTransform from './wrappers/gdalGetGeoTransform.js';\nimport wGDALTranslate from './wrappers/gdalTranslate.js';\nimport wGDALWarp from './wrappers/gdalWarp.js';\n\nconst DATASETPATH = '/datasets';\n\nlet initialized = false;\n\nlet registry = {};\nlet errorHandling = {\n    // In order to make enums available from JS it's necessary to use embind, which seems like\n    // overkill for something this small. But this is a replication of the CPLErr enum in\n    // cpl_error.h\n    CPLErr: {\n        CENone: 0,\n        CEDebug: 1,\n        CEWarning: 2,\n        CEFailure: 3,\n        CEFatal: 4\n    },\n    // These will be populated by onRuntimeInitialized, below\n    CPLErrorReset: null,\n    CPLGetLastErrorMsg: null,\n    CPLGetLastErrorNo: null,\n    CPLGetLastErrorType: null\n};\n\nself.Module = {\n    'print': function (text) { console.log('stdout: ' + text); },\n    'printErr': function (text) { console.log('stderr: ' + text); },\n    // Optimized builds contain a .js.mem file which is loaded asynchronously;\n    // this waits until that has finished before performing further setup.\n    'onRuntimeInitialized': function () {\n        // Initialize GDAL\n        self.Module.ccall('GDALAllRegister', null, [], []);\n\n        // Set up error handling\n        errorHandling.CPLErrorReset = self.Module.cwrap('CPLErrorReset', null, []);\n        errorHandling.CPLGetLastErrorMsg = self.Module.cwrap('CPLGetLastErrorMsg', 'string', []);\n        errorHandling.CPLGetLastErrorNo = self.Module.cwrap('CPLGetLastErrorNo', 'number', []);\n        errorHandling.CPLGetLastErrorType = self.Module.cwrap('CPLGetLastErrorType', 'number', []);\n        // Get a \"function pointer\" to the built-in quiet error handler so that errors don't\n        // cause tons of console noise.\n        const cplQuietFnPtr = Runtime.addFunction(\n            self.Module.cwrap('CPLQuietErrorHandler', 'number', ['number'])\n        );\n\n        // Then set the error handler to the quiet handler.\n        self.Module.ccall('CPLSetErrorHandler', 'number', ['number'], [cplQuietFnPtr]);\n\n        // Set up JS proxy functions\n        // Note that JS Number types are used to represent pointers, which means that\n        // any time we want to pass a pointer to an object, such as in GDALOpen, which in\n        // C returns a pointer to a GDALDataset, we need to use 'number'.\n        //\n        registry.GDALOpen = wGDALOpen(\n            self.Module.cwrap('GDALOpen', 'number', ['string']),\n            errorHandling,\n            DATASETPATH\n        );\n        registry.GDALClose = wGDALClose(\n            self.Module.cwrap('GDALClose', 'number', ['number']),\n            errorHandling\n        );\n        registry.GDALGetRasterCount = wGDALGetRasterCount(\n            self.Module.cwrap('GDALGetRasterCount', 'number', ['number']),\n            errorHandling\n        );\n        registry.GDALGetRasterXSize = wGDALGetRasterXSize(\n            self.Module.cwrap('GDALGetRasterXSize', 'number', ['number']),\n            errorHandling\n        );\n        registry.GDALGetRasterYSize = wGDALGetRasterYSize(\n            self.Module.cwrap('GDALGetRasterYSize', 'number', ['number']),\n            errorHandling\n        );\n        registry.GDALGetProjectionRef = wGDALGetProjectionRef(\n            self.Module.cwrap('GDALGetProjectionRef', 'string', ['number']),\n            errorHandling\n        );\n        registry.GDALGetGeoTransform = wGDALGetGeoTransform(\n            self.Module.cwrap('GDALGetGeoTransform', 'number', [\n                'number', 'number'\n            ]),\n            errorHandling\n        );\n        registry.GDALTranslate = wGDALTranslate(\n            self.Module.cwrap('GDALTranslate', 'number', [\n                'string', // Output path\n                'number', // GDALDatasetH source dataset\n                'number', // GDALTranslateOptions *\n                'number' // int * to use for error reporting\n            ]),\n            errorHandling,\n            DATASETPATH\n        );\n        registry.GDALWarp = wGDALWarp(\n            self.Module.cwrap('GDALWarp', 'number', [\n                'string', // Destination dataset path or NULL\n                'number', // GDALDatasetH destination dataset or NULL\n                'number', // Number of input datasets\n                'number', // GDALDatasetH * list of source datasets\n                'number', // GDALWarpAppOptions *\n                'number' // int * to use for error reporting\n            ]),\n            errorHandling,\n            DATASETPATH\n        );\n        registry.LoamFlushFS = function () {\n            let datasetFolders = FS.lookupPath(DATASETPATH).node.contents;\n\n            Object.values(datasetFolders).forEach(node => {\n                FS.unmount(FS.getPath(node));\n                FS.rmdir(FS.getPath(node));\n            });\n            return true;\n        };\n        FS.mkdir(DATASETPATH);\n        initialized = true;\n        postMessage({ready: true});\n    }\n};\n\n// Load gdal.js. This will populate the Module object, and then call\n// Module.onRuntimeInitialized() when it is ready for user code to interact with it.\nimportScripts('gdal.js');\n\nonmessage = function (msg) {\n    if (!initialized) {\n        postMessage({success: false, message: 'Runtime not yet initialized'});\n        return;\n    }\n    if (msg.data['function'] && registry[msg.data['function']]) {\n        let func = registry[msg.data['function']];\n        let args = msg.data.arguments;\n\n        // TODO: More error handling\n        try {\n            let result = func(...args);\n\n            postMessage({\n                success: true,\n                result: result,\n                id: msg.data.id\n            });\n        } catch (error) {\n            postMessage({\n                success: false,\n                message: error.message,\n                id: msg.data.id\n            });\n        }\n        return;\n    }\n    postMessage({\n        success: false,\n        message: 'No \"function\" key specified or function not found',\n        id: msg.data.id\n    });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/worker.js","import randomKey from '../randomKey.js';\n\n/* global FS WORKERFS */\nexport default function (GDALOpen, errorHandling, rootPath) {\n    return function (file) {\n        let filename;\n        let directory = rootPath + '/' + randomKey();\n\n        FS.mkdir(directory);\n\n        if (file instanceof File) {\n            filename = file.name;\n            FS.mount(WORKERFS, { files: [file] }, directory);\n        } else if (file instanceof Blob) {\n            filename = 'geotiff.tif';\n            FS.mount(WORKERFS, { blobs: [{ name: filename, data: file }] }, directory);\n        }\n        let filePath = directory + '/' + filename;\n        let datasetPtr = GDALOpen(filePath);\n        let errorType = errorHandling.CPLGetLastErrorType();\n\n        // Check for errors; clean up and throw if error is detected\n        if (errorType === errorHandling.CPLErr.CEFailure ||\n                errorType === errorHandling.CPLErr.CEFatal) {\n            FS.unmount(directory);\n            FS.rmdir(directory);\n            let message = errorHandling.CPLGetLastErrorMsg();\n\n            throw new Error(message);\n        } else {\n            return {\n                datasetPtr: datasetPtr,\n                filePath: filePath,\n                directory: directory,\n                filename: filename\n            };\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/wrappers/gdalOpen.js","/* global FS */\nexport default function (GDALClose, errorHandling) {\n    return function (datasetPtr, directory, datasetPath, returnFileBytes = false) {\n        GDALClose(datasetPtr);\n        let result = [];\n\n        if (returnFileBytes) {\n            result = FS.readFile(datasetPath, { encoding: 'binary' });\n        }\n        FS.unmount(directory);\n        FS.rmdir(directory);\n\n        let errorType = errorHandling.CPLGetLastErrorType();\n\n        // Check for errors; throw if error is detected\n        if (errorType === errorHandling.CPLErr.CEFailure ||\n                errorType === errorHandling.CPLErr.CEFatal) {\n            let message = errorHandling.CPLGetLastErrorMsg();\n\n            throw new Error(message);\n        } else {\n            return result;\n        }\n    };\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/wrappers/gdalClose.js","export default function (GDALGetRasterCount, errorHandling) {\n    return function (datasetPtr) {\n        let result = GDALGetRasterCount(datasetPtr);\n        let errorType = errorHandling.CPLGetLastErrorType();\n\n        // Check for errors; clean up and throw if error is detected\n        if (errorType === errorHandling.CPLErr.CEFailure ||\n                errorType === errorHandling.CPLErr.CEFatal) {\n            let message = errorHandling.CPLGetLastErrorMsg();\n\n            throw new Error(message);\n        } else {\n            return result;\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/wrappers/gdalGetRasterCount.js","export default function (GDALGetRasterXSize, errorHandling) {\n    return function (datasetPtr) {\n        let result = GDALGetRasterXSize(datasetPtr);\n        let errorType = errorHandling.CPLGetLastErrorType();\n\n        // Check for errors; clean up and throw if error is detected\n        if (errorType === errorHandling.CPLErr.CEFailure ||\n                errorType === errorHandling.CPLErr.CEFatal) {\n            let message = errorHandling.CPLGetLastErrorMsg();\n\n            throw new Error(message);\n        } else {\n            return result;\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/wrappers/gdalGetRasterXSize.js","export default function (GDALGetRasterYSize, errorHandling) {\n    return function (datasetPtr) {\n        let result = GDALGetRasterYSize(datasetPtr);\n        let errorType = errorHandling.CPLGetLastErrorType();\n\n        // Check for errors; clean up and throw if error is detected\n        if (errorType === errorHandling.CPLErr.CEFailure ||\n                errorType === errorHandling.CPLErr.CEFatal) {\n            let message = errorHandling.CPLGetLastErrorMsg();\n\n            throw Error(message);\n        } else {\n            return result;\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/wrappers/gdalGetRasterYSize.js","export default function (GDALGetProjectionRef, errorHandling) {\n    return function (datasetPtr) {\n        let result = GDALGetProjectionRef(datasetPtr);\n        let errorType = errorHandling.CPLGetLastErrorType();\n\n        // Check for errors; clean up and throw if error is detected\n        if (errorType === errorHandling.CPLErr.CEFailure ||\n                errorType === errorHandling.CPLErr.CEFatal) {\n            let message = errorHandling.CPLGetLastErrorMsg();\n\n            throw new Error(message);\n        } else {\n            return result;\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/wrappers/gdalGetProjectionRef.js","/* global Module */\nexport default function (GDALGetGeoTransform, errorHandling) {\n    return function (datasetPtr) {\n        // This is the first wrapper where things get a bit hairy; the C function follows a common C\n        // pattern where an array to store the results is allocated and passed into the function,\n        // which populates the array with the results. Emscripten supports passing arrays to\n        // functions, but it always creates a *copy* of the array, which means that the original JS\n        // array remains unchanged, which isn't what we want in this case. So first, we have to\n        // malloc an array inside the Emscripten heap with the correct size. In this case that is 6\n        // because the GDAL affine transform array has six elements.\n        let byteOffset = Module._malloc(6 * Float64Array.BYTES_PER_ELEMENT);\n\n        // byteOffset is now a pointer to the start of the double array in Emscripten heap space\n        // GDALGetGeoTransform dumps 6 values into the passed double array.\n        GDALGetGeoTransform(datasetPtr, byteOffset);\n\n        // Module.HEAPF64 provides a view into the Emscripten heap, as an array of doubles.\n        // Therefore, our byte offset from _malloc needs to be converted into a double offset, so we\n        // divide it by the number of bytes per double, and then get a subarray of those six\n        // elements off the Emscripten heap.\n        let geoTransform = Module.HEAPF64.subarray(\n            byteOffset / Float64Array.BYTES_PER_ELEMENT,\n            byteOffset / Float64Array.BYTES_PER_ELEMENT + 6\n        );\n        let errorType = errorHandling.CPLGetLastErrorType();\n\n        // Check for errors; clean up and throw if error is detected\n        if (errorType === errorHandling.CPLErr.CEFailure ||\n                errorType === errorHandling.CPLErr.CEFatal) {\n            Module._free(byteOffset);\n            let message = errorHandling.CPLGetLastErrorMsg();\n\n            throw new Error(message);\n        } else {\n            // To avoid memory leaks in the Emscripten heap, we need to free up the memory we allocated\n            // after we've converted it into a Javascript object.\n            let result = Array.from(geoTransform);\n\n            Module._free(byteOffset);\n\n            return result;\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/wrappers/gdalGetGeoTransform.js","import randomKey from '../randomKey.js';\nimport guessFileExtension from '../guessFileExtension.js';\n\n/* global Module, FS, MEMFS */\nexport default function (GDALTranslate, errorHandling, rootPath) {\n    // Args is expected to be an array of strings that could function as arguments to gdal_translate\n    return function (dataset, args) {\n        // So first, we need to allocate Emscripten heap space sufficient to store each string as a\n        // null-terminated C string.\n        // Because the C function signature is char **, this array of pointers is going to need to\n        // get copied into Emscripten heap space eventually, so we're going to prepare by storing\n        // the pointers as a typed array so that we can more easily copy it into heap space later.\n        let argPtrsArray = Uint32Array.from(args.map(argStr => {\n            return Module._malloc(Module.lengthBytesUTF8(argStr) + 1); // +1 for the null terminator byte\n        }).concat([0]));\n        // ^ In addition to each individual argument being null-terminated, the GDAL docs specify that\n        // GDALTranslateOptionsNew takes its options passed in as a null-terminated array of\n        // pointers, so we have to add on a null (0) byte at the end.\n\n        // Next, we need to write each string from the JS string array into the Emscripten heap space\n        // we've allocated for it.\n        args.forEach(function (argStr, i) {\n            Module.stringToUTF8(argStr, argPtrsArray[i], Module.lengthBytesUTF8(argStr) + 1);\n        });\n\n        // Now, as mentioned above, we also need to copy the pointer array itself into heap space.\n        let argPtrsArrayPtr = Module._malloc(argPtrsArray.length * argPtrsArray.BYTES_PER_ELEMENT);\n\n        Module.HEAPU32.set(argPtrsArray, argPtrsArrayPtr / argPtrsArray.BYTES_PER_ELEMENT);\n\n        // Whew, all finished. argPtrsArrayPtr is now the address of the start of the list of\n        // pointers in Emscripten heap space. Each pointer identifies the address of the start of a\n        // parameter string, also stored in heap space. This is the direct equivalent of a char **,\n        // which is what GDALTranslateOptionsNew requires.\n        let translateOptionsPtr = Module.ccall('GDALTranslateOptionsNew', 'number',\n            ['number', 'number'],\n            [argPtrsArrayPtr, null]\n        );\n        // Validate that the options were correct\n        let optionsErrType = errorHandling.CPLGetLastErrorType();\n\n        if (optionsErrType === errorHandling.CPLErr.CEFailure ||\n                optionsErrType === errorHandling.CPLErr.CEFatal) {\n            Module._free(argPtrsArrayPtr);\n            // Don't try to free the null terminator byte\n            argPtrsArray.subarray(0, argPtrsArray.length - 1).forEach(ptr => Module._free(ptr));\n            const message = errorHandling.CPLGetLastErrorMsg();\n\n            throw new Error(message);\n        }\n\n        // Now that we have our translate options, we need to make a file location to hold the output.\n        let directory = rootPath + '/' + randomKey();\n\n        FS.mkdir(directory);\n        // This makes it easier to remove later because we can just unmount rather than recursing\n        // through the whole directory structure.\n        FS.mount(MEMFS, {}, directory);\n        let filename = randomKey(8) + '.' + guessFileExtension(args);\n        let filePath = directory + '/' + filename;\n        // And then we can kick off the actual translation process.\n        // TODO: The last parameter is an int* that can be used to detect certain kinds of errors,\n        // but I'm not sure how it works yet and whether it gives the same or different information\n        // than CPLGetLastErrorType\n        // We can get some error information out of the final pbUsageError parameter, which is an\n        // int*, so malloc ourselves an int and set it to 0 (False)\n        let usageErrPtr = Module._malloc(Int32Array.BYTES_PER_ELEMENT);\n\n        Module.setValue(usageErrPtr, 0, 'i32');\n        let newDatasetPtr = GDALTranslate(filePath, dataset, translateOptionsPtr, usageErrPtr);\n        let errorType = errorHandling.CPLGetLastErrorType();\n        // If we ever want to use the usage error pointer:\n        // let usageErr = Module.getValue(usageErrPtr, 'i32');\n\n        // The final set of cleanup we need to do, in a function to avoid writing it twice.\n        function cleanUp() {\n            Module.ccall('GDALTranslateOptionsFree', null, ['number'], [translateOptionsPtr]);\n            Module._free(argPtrsArrayPtr);\n            Module._free(usageErrPtr);\n            // Don't try to free the null terminator byte\n            argPtrsArray.subarray(0, argPtrsArray.length - 1).forEach(ptr => Module._free(ptr));\n        }\n\n        // Check for errors; clean up and throw if error is detected\n        if (errorType === errorHandling.CPLErr.CEFailure ||\n                errorType === errorHandling.CPLErr.CEFatal) {\n            cleanUp();\n            const message = errorHandling.CPLGetLastErrorMsg();\n\n            throw new Error(message);\n        } else {\n            const result = {\n                datasetPtr: newDatasetPtr,\n                filePath: filePath,\n                directory: directory,\n                filename: filename\n            };\n\n            cleanUp();\n\n            return result;\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/wrappers/gdalTranslate.js","import randomKey from '../randomKey.js';\nimport guessFileExtension from '../guessFileExtension.js';\n\n/* global Module, FS, MEMFS */\nexport default function (GDALWarp, errorHandling, rootPath) {\n    // Args is expected to be an array of strings that could function as arguments to gdal_translate\n    return function (dataset, args) {\n        // So first, we need to allocate Emscripten heap space sufficient to store each string as a\n        // null-terminated C string.\n        // Because the C function signature is char **, this array of pointers is going to need to\n        // get copied into Emscripten heap space eventually, so we're going to prepare by storing\n        // the pointers as a typed array so that we can more easily copy it into heap space later.\n        let argPtrsArray = Uint32Array.from(args.map(argStr => {\n            return Module._malloc(Module.lengthBytesUTF8(argStr) + 1); // +1 for the null terminator byte\n        }).concat([0]));\n        // ^ In addition to each individual argument being null-terminated, the GDAL docs specify that\n        // GDALTranslateOptionsNew takes its options passed in as a null-terminated array of\n        // pointers, so we have to add on a null (0) byte at the end.\n\n        // Next, we need to write each string from the JS string array into the Emscripten heap space\n        // we've allocated for it.\n        args.forEach(function (argStr, i) {\n            Module.stringToUTF8(argStr, argPtrsArray[i], Module.lengthBytesUTF8(argStr) + 1);\n        });\n\n        // Now, as mentioned above, we also need to copy the pointer array itself into heap space.\n        let argPtrsArrayPtr = Module._malloc(argPtrsArray.length * argPtrsArray.BYTES_PER_ELEMENT);\n\n        Module.HEAPU32.set(argPtrsArray, argPtrsArrayPtr / argPtrsArray.BYTES_PER_ELEMENT);\n\n        // Whew, all finished. argPtrsArrayPtr is now the address of the start of the list of\n        // pointers in Emscripten heap space. Each pointer identifies the address of the start of a\n        // parameter string, also stored in heap space. This is the direct equivalent of a char **,\n        // which is what GDALWarpAppOptionsNew requires.\n        let warpAppOptionsPtr = Module.ccall('GDALWarpAppOptionsNew', 'number',\n            ['number', 'number'],\n            [argPtrsArrayPtr, null]\n        );\n        // Validate that the options were correct\n        let optionsErrType = errorHandling.CPLGetLastErrorType();\n\n        if (optionsErrType === errorHandling.CPLErr.CEFailure ||\n                optionsErrType === errorHandling.CPLErr.CEFatal) {\n            Module._free(argPtrsArrayPtr);\n            // Don't try to free the null terminator byte\n            argPtrsArray.subarray(0, argPtrsArray.length - 1).forEach(ptr => Module._free(ptr));\n            const message = errorHandling.CPLGetLastErrorMsg();\n\n            throw new Error(message);\n        }\n\n        // Now that we have our translate options, we need to make a file location to hold the output.\n        let directory = rootPath + '/' + randomKey();\n\n        FS.mkdir(directory);\n        // This makes it easier to remove later because we can just unmount rather than recursing\n        // through the whole directory structure.\n        FS.mount(MEMFS, {}, directory);\n        let filename = randomKey(8) + '.' + guessFileExtension(args);\n        let filePath = directory + '/' + filename;\n        // And then we can kick off the actual warping process.\n        // TODO: The last parameter is an int* that can be used to detect certain kinds of errors,\n        // but I'm not sure how it works yet and whether it gives the same or different information\n        // than CPLGetLastErrorType\n        // We can get some error information out of the final pbUsageError parameter, which is an\n        // int*, so malloc ourselves an int and set it to 0 (False)\n        let usageErrPtr = Module._malloc(Int32Array.BYTES_PER_ELEMENT);\n\n        Module.setValue(usageErrPtr, 0, 'i32');\n\n        // We also need a GDALDatasetH * list of datasets. Since we're just warping a single dataset\n        // at a time, we don't need to do anything fancy here.\n        let datasetListPtr = Module._malloc(4); // 32-bit pointer\n\n        Module.setValue(datasetListPtr, dataset, '*'); // Set datasetListPtr to the address of dataset\n        let newDatasetPtr = GDALWarp(\n            filePath, // Output\n            0, // NULL because filePath is not NULL\n            1, // Number of input datasets; this is always called on a single dataset\n            datasetListPtr,\n            warpAppOptionsPtr,\n            usageErrPtr\n        );\n        let errorType = errorHandling.CPLGetLastErrorType();\n        // If we ever want to use the usage error pointer:\n        // let usageErr = Module.getValue(usageErrPtr, 'i32');\n\n        // The final set of cleanup we need to do, in a function to avoid writing it twice.\n        function cleanUp() {\n            Module.ccall('GDALWarpAppOptionsFree', null, ['number'], [warpAppOptionsPtr]);\n            Module._free(argPtrsArrayPtr);\n            Module._free(usageErrPtr);\n            // Don't try to free the null terminator byte\n            argPtrsArray.subarray(0, argPtrsArray.length - 1).forEach(ptr => Module._free(ptr));\n        }\n\n        // Check for errors; clean up and throw if error is detected\n        if (errorType === errorHandling.CPLErr.CEFailure ||\n                errorType === errorHandling.CPLErr.CEFatal) {\n            cleanUp();\n            const message = errorHandling.CPLGetLastErrorMsg();\n\n            throw new Error(message);\n        } else {\n            const result = {\n                datasetPtr: newDatasetPtr,\n                filePath: filePath,\n                directory: directory,\n                filename: filename\n            };\n\n            cleanUp();\n\n            return result;\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/wrappers/gdalWarp.js"],"sourceRoot":""}